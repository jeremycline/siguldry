// SPDX-License-Identifier: MIT
// Copyright (c) Microsoft Corporation.

//! The structures used in the Sigul protocol.
//!
//! All structures described in this documenation are to be sent in network byte order (big endian).
//!
//! # Outer TLS Session
//!
//! Both the client and server connect to the bridge service using TLS, authenticated via client
//! certificates. Once the connection is established, the connecting side (the client or server)
//! sends a protocol header and waits for an acknowledgement from the bridge. After the
//! acknowledgement is received, no further communication occurs in the outer TLS session.
//!
//! ## Protocol Header and Ack
//!
//! Every connection to the bridge must begin with the protocol header, which announces the protocol
//! version to follow. The server may reject the request if the version is unknown or unsupported. A
//! server may support multiple versions, but must always use the version requested by the client if
//! it is supported.
//!
//! |--------------------------|
//! |      Protocol Header     |
//! |--------------------------|
//! | u64 | Magic number       |
//! | u32 | Protocol version   |
//! | u8  | Role               |
//! |--------------------------|
//!
//! The bridge responds with an acknowledgement which includes a session ID for the connection and
//! a status to indicate whether the inner TLS connection can proceed.
//!
//! |--------------------------|
//! |      Protocol Ack        |
//! |--------------------------|
//! | u128 | Session ID        |
//! | u8   | Bridge status     |
//! |--------------------------|
//!
//! The session ID is a UUID generated by the bridge and provided to both the client and the server.
//! This can be used to identify a connection on both the client and server.
//!
//! Refer to [`BridgeStatus`] for possible status values.
//!
//! The protocol version is increased whenever any of the following structures are changed. Thus,
//! all structures described below are specific to version 2 of the protocol.
//!
//! # Inner TLS Session
//!
//! After the protocol header is acknowledged, the client starts a second TLS session within the
//! first one. In this session, the client must configure the TLS session to accept the Sigul
//! server's hostname and must present its client TLS certificate. All future communication occurs
//! over this nested TLS session.
//!
//! ## Frames
//!
//! Each message in the inner TLS session must start with a frame, which describes the size of the
//! data to follow. Requests include two sections; the first is a JSON-serialized, UTF-8 encoded
//! dictionary describing the request and its parameters. The second section is an arbitrary,
//! request-specific binary blob. This binary blob is used exclusively for various signing requests
//! and management commands do not include one. When the command does not have a binary blob, the
//! size in the frame must be set to 0.
//!
//! |---------------------------|
//! |        Frame Header       |
//! |---------------------------|
//! | u64 | JSON size (bytes)   |
//! | u64 | Binary size (bytes) |
//! |---------------------------|

use openssl::nid::Nid;
use serde::{Deserialize, Serialize};
use tokio::io::{AsyncRead, AsyncReadExt};
use tokio_openssl::SslStream;
use tracing::instrument;
use uuid::Uuid;
use zerocopy::{
    byteorder::network_endian::{U128, U32, U64},
    Immutable, IntoBytes, KnownLayout, TryFromBytes,
};

use crate::v2::error::ConnectionError;

/// Magic number used in the protocol header.
pub const MAGIC: U64 = U64::from_bytes([83, 73, 71, 85, 76, 68, 82, 89]);
/// The Sigul wire protocol version this implementation supports
pub const PROTOCOL_VERSION: U32 = U32::new(2);

/// The possible roles a connection can have.
///
/// This is sent in the [`ProtocolHeader`]. The bridge listens on two separate ports for client
/// connections and server connections, but it is easy to misconfigure the client, server, or bridge
/// such that a client connects to the server port or vice versa. This header field exists to ensure
/// such misconfigurations are clearly reported by the bridge.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Role {
    /// Clients should use this role in their protocol header.
    Client = 0,
    /// Server should use this role in their protocol header.
    Server = 1,
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Role::Client => write!(f, "client"),
            Role::Server => write!(f, "server"),
        }
    }
}

/// Every connection to the bridge begins with a protocol header to announce the version it expects
/// to use as well as the [`Role`] it intends to take.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone)]
pub(crate) struct ProtocolHeader {
    /// Each connection starts with a [`MAGIC`] number. While the version and role also have a fairly
    /// restricted set of valid values, this makes it even more likely a random incoming connection
    /// doesn't send a valid header so the bridge can hang up sooner. This isn't a security thing, just
    /// a "make it very likely you can log the right error" thing.
    pub(crate) magic: U64,
    /// The protocol version being requested by the connection; the current version is
    /// [`PROTOCOL_VERSION`].
    pub(crate) version: U32,
    /// The [`Role`] of this connection; the bridge should listen on entirely different ports and so it
    /// should know whether each connection is a client or a server. This exists primarily to help catch
    /// mis-configurations where the client or server connects to the other's port on the bridge.
    pub(crate) role: Role,
}

/// Part of the protocol Ack sent by the bridge to indicate whether the connection can continue.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub(crate) enum BridgeStatus {
    /// The requested protocol version and role is acceptable to the bridge.
    Ok = 0,
    /// The requested version is unsupported.
    UnsupportedVersion = 1,
    /// The requested role is invalid or not correct for the given bridge address (e.g. a server
    /// connected to the client port).
    InvalidRole = 2,
    /// The client certificate is signed by a valid CA, but does not include a Common Name field.
    MissingCommonName = 3,
    /// The request did not begin with the correct magic number.
    MissingMagic = 4,
}

impl std::fmt::Display for BridgeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BridgeStatus::Ok => write!(f, "OK"),
            BridgeStatus::UnsupportedVersion => {
                write!(f, "The requested protocol version is not supported")
            }
            BridgeStatus::InvalidRole => write!(
                f,
                "The requested role is invalid for the bridge address and port"
            ),
            BridgeStatus::MissingCommonName => {
                write!(f, "The client certificate does not contain a CommonName")
            }
            BridgeStatus::MissingMagic => {
                write!(f, "The connection didn't start with the magic number")
            }
        }
    }
}

/// The bridge sends this acknowledgement to connections after receiving the protocol header.
/// The client and server can use this to determine if the inner connection can proceed, and
/// it also includes a session ID so logs across the services can be corrolated.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone)]
pub(crate) struct ProtocolAck {
    pub(crate) session_id: U128,
    status: BridgeStatus,
}

impl ProtocolAck {
    pub fn new(status: BridgeStatus) -> Self {
        Self {
            session_id: U128::new(Uuid::now_v7().as_u128()),
            status,
        }
    }

    #[instrument(level = "trace", skip_all, err)]
    pub(crate) async fn check<C: AsyncRead + Unpin>(conn: &mut C) -> Result<Uuid, ConnectionError> {
        let mut ack_buf = [0_u8; std::mem::size_of::<Self>()];
        conn.read_exact(&mut ack_buf).await?;
        let ack = Self::try_ref_from_bytes(&ack_buf)?;
        let session_id = Uuid::from_u128(ack.session_id.get());
        tracing::debug!(?session_id, status=?ack.status, "Bridge acknowledgement received");

        match ack.status {
            BridgeStatus::Ok => Ok(session_id),
            other => Err(Error::Bridge(other.to_string()).into()),
        }
    }
}

impl ProtocolHeader {
    /// Create a new protocol header for the given role.
    pub(crate) fn new(role: Role) -> Self {
        Self {
            magic: MAGIC,
            version: PROTOCOL_VERSION,
            role,
        }
    }

    pub(crate) fn check(&self, expected_role: Role) -> BridgeStatus {
        if self.magic != MAGIC {
            BridgeStatus::MissingMagic
        } else if self.version != PROTOCOL_VERSION {
            BridgeStatus::UnsupportedVersion
        } else if self.role != expected_role {
            BridgeStatus::InvalidRole
        } else {
            BridgeStatus::Ok
        }
    }
}

impl From<Role> for ProtocolHeader {
    fn from(role: Role) -> Self {
        ProtocolHeader::new(role)
    }
}

/// Get the remote connection's commonName from its certificate.
pub(crate) fn peer_common_name<S>(stream: &SslStream<S>) -> Result<String, Error> {
    stream
        .ssl()
        .peer_certificate()
        .and_then(|cert| {
            cert.subject_name()
                .entries_by_nid(Nid::COMMONNAME)
                .next()
                .and_then(|entry| entry.data().as_utf8().ok())
        })
        .map(|common_name| common_name.to_string())
        .ok_or(Error::MissingCommonName)
}

/// Possible errors due to protocol violations.
#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum Error {
    /// The client certificate does not include a Common Name, which is used to determine the
    /// username of the client.
    #[error("The peer's certificate does not include a Common Name")]
    MissingCommonName,
    #[error("The frame was invalid: {0}")]
    Framing(String),
    #[error("The bridge rejected the protocol header: {0}")]
    Bridge(String),
}

/// Each client request or server response starts with a frame that describes the size of the request
/// to follow.
///
/// TODO: if something like JSON doesn't work for all commands, we could do something where a
/// request/response is a list of frames so they can have mixed content types. But I think JSON will
/// be fine for everything, so let's keep it simple for now.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone)]
pub(crate) struct Frame {
    /// The
    pub(crate) json_size: U64,
    pub(crate) binary_size: U64,
}

// TODO maybe don't be fancy. Request responses always need to be JSON, and optionally can have an arbitrary command-specific bag of bytes following it
// Drop the content type, size becomes request_size, add payload_size.

impl Frame {
    /// Create a new frame.
    pub fn new(json_size: u64, binary_size: u64) -> Self {
        Self {
            json_size: U64::new(json_size),
            binary_size: U64::new(binary_size),
        }
    }
}

pub(crate) mod json {
    use serde::{Deserialize, Serialize};
    use uuid::Uuid;

    use crate::v2::protocol::ServerError;

    /// The structure used by the client when sending requests to the server.
    ///
    /// # Example
    /// ```
    /// # use serde_json::Result;
    /// # use siguldry::v2::protocol::json::OuterRequest;
    /// # fn main() -> Result<()> {
    /// let data = r#"
    ///     {
    ///         "session_id": "00000000-0000-0000-0000-000000000000",
    ///         "request_id": 42,
    ///         "request": {
    ///             "who_am_i": {}
    ///         }
    ///     }
    /// "#;
    /// let whoami_response: OuterResponse = serde_json::from_str(data)?;
    ///
    /// # Ok(())
    /// }
    /// ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "snake_case")]
    pub(crate) struct OuterRequest {
        /// The session ID this request is a part of.
        pub(crate) session_id: Uuid,
        /// The request ID; this should be a unique integer within the session,
        /// but has no other requirements. The response will include the same ID
        /// so it can be used to ensure the response matches the request.
        pub(crate) request_id: u64,
        /// The actual client request for the server.
        pub(crate) request: Request,
    }

    /// The structure used by the server when sending responses to the client.
    ///
    /// # Example
    /// ```
    /// # use serde_json::Result;
    /// # use siguldry::v2::protocol::json::OuterResponse;
    /// # fn main() -> Result<()> {
    /// let data = r#"
    ///     {
    ///         "session_id": "00000000-0000-0000-0000-000000000000",
    ///         "request_id": 42,
    ///         "response": {
    ///             "who_am_i": {"user": "dadams"}
    ///         }
    ///     }
    /// "#;
    /// let whoami_response: OuterResponse = serde_json::from_str(data)?;
    ///
    /// # Ok(())
    /// }
    /// ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "snake_case")]
    pub(crate) struct OuterResponse {
        /// The session ID this request is a part of.
        pub(crate) session_id: Uuid,
        /// The request ID; this should be a unique integer within the session,
        /// but has no other requirements. The response will include the same ID
        /// so it can be used to ensure the response matches the request.
        pub(crate) request_id: u64,
        /// The serialized [`Request`] or [`Response`].
        pub(crate) response: Response,
    }

    /// The set of requests a client and server must support.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "snake_case")]
    pub(crate) enum Request {
        WhoAmI {},
        NewUser { username: String },
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(rename_all = "snake_case")]
    pub(crate) enum Response {
        WhoAmI { user: String },
        Error { reason: ServerError },
    }
}

/// Errors that occur when handling client requests.
///
/// These errors are particular to the request and the server will continue
/// to process additional requests on the connection.
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(rename_all = "snake_case")]
pub enum ServerError {}
