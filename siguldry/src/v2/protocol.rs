// SPDX-License-Identifier: MIT
// Copyright (c) Microsoft Corporation.

//! The structures used in the Sigul protocol.
//!
//! All structures described in this documenation are to be sent in network byte order (big endian).
//!
//! # Outer TLS Session
//!
//! Both the client and server connect to the bridge service using TLS, authenticated via client
//! certificates. Once the connection is established, the connecting side (the client or server)
//! sends a protocol header and waits for an acknowledgement from the bridge. After the
//! acknowledgement is received, no further communication occurs in the outer TLS session.
//!
//! ## Protocol Header and Ack
//!
//! Every connection to the bridge must begin with the protocol header, which announces the protocol
//! version to follow. The server may reject the request if the version is unknown or unsupported. A
//! server may support multiple versions, but must always use the version requested by the client if
//! it is supported.
//!
//! |--------------------------|
//! |      Protocol Header     |
//! |--------------------------|
//! | u64 | Magic number       |
//! | u32 | Protocol version   |
//! | u8  | Role               |
//! |--------------------------|
//!
//! The bridge responds with an acknowledgement which includes a session ID for the connection and
//! a status to indicate whether the inner TLS connection can proceed.
//!
//! |--------------------------|
//! |      Protocol Ack        |
//! |--------------------------|
//! | u128 | Session ID        |
//! | u8   | Bridge status     |
//! |--------------------------|
//!
//! The session ID is a UUID generated by the bridge and provided to both the client and the server.
//! This can be used to identify a connection on both the client and server.
//!
//! Refer to [`BridgeStatus`] for possible status values.
//!
//! The protocol version is increased whenever any of the following structures are changed. Thus,
//! all structures described below are specific to version 2 of the protocol.
//!
//! # Inner TLS Session
//!
//! After the protocol header is acknowledged, the client starts a second TLS session within the
//! first one. In this session, the client must configure the TLS session to accept the Sigul
//! server's hostname and must present its client TLS certificate. All future communication occurs
//! over this nested TLS session.
//!
//! ## Frames
//!
//! Each message in the inner TLS session must start with a frame, which describes the size of the
//! data to follow. Requests include two sections; the first is a JSON-serialized, UTF-8 encoded
//! dictionary describing the request and its parameters. The second section is an arbitrary,
//! request-specific binary blob. This binary blob is used exclusively for various signing requests
//! and management commands do not include one. When the command does not have a binary blob, the
//! size in the frame must be set to 0.
//!
//! |---------------------------|
//! |        Frame Header       |
//! |---------------------------|
//! | u64 | JSON size (bytes)   |
//! | u64 | Binary size (bytes) |
//! |---------------------------|

use openssl::nid::Nid;
use serde::{Deserialize, Serialize};
use tokio::io::{AsyncRead, AsyncReadExt};
use tokio_openssl::SslStream;
use tracing::instrument;
use uuid::Uuid;
use zerocopy::{
    byteorder::network_endian::{U128, U32, U64},
    Immutable, IntoBytes, KnownLayout, TryFromBytes,
};

use crate::v2::error::ConnectionError;

/// Magic number used in the protocol header.
pub const MAGIC: U64 = U64::from_bytes([83, 73, 71, 85, 76, 68, 82, 89]);
/// The Sigul wire protocol version this implementation supports
pub const PROTOCOL_VERSION: U32 = U32::new(2);

#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone, Copy)]
#[repr(u8)]
pub(crate) enum ContentType {
    Json = 0,
}

/// The possible roles a connection can have.
///
/// This is sent in the [`ProtocolHeader`]. The bridge listens on two separate ports for client
/// connections and server connections, but it is easy to misconfigure the client, server, or bridge
/// such that a client connects to the server port or vice versa. This header field exists to ensure
/// such misconfigurations are clearly reported by the bridge.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Role {
    /// Clients should use this role in their protocol header.
    Client = 0,
    /// Server should use this role in their protocol header.
    Server = 1,
}

impl std::fmt::Display for Role {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Role::Client => write!(f, "client"),
            Role::Server => write!(f, "server"),
        }
    }
}

/// Every connection to the bridge begins with a protocol header to announce the version it expects
/// to use as well as the [`Role`] it intends to take.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone)]
pub(crate) struct ProtocolHeader {
    /// Each connection starts with a [`MAGIC`] number. While the version and role also have a fairly
    /// restricted set of valid values, this makes it even more likely a random incoming connection
    /// doesn't send a valid header so the bridge can hang up sooner. This isn't a security thing, just
    /// a "make it very likely you can log the right error" thing.
    magic: U64,
    /// The protocol version being requested by the connection; the current version is
    /// [`PROTOCOL_VERSION`].
    version: U32,
    /// The [`Role`] of this connection; the bridge should listen on entirely different ports and so it
    /// should know whether each connection is a client or a server. This exists primarily to help catch
    /// mis-configurations where the client or server connects to the other's port on the bridge.
    role: Role,
}

/// Part of the protocol Ack sent by the bridge to indicate whether the connection can continue.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub(crate) enum BridgeStatus {
    /// The requested protocol version and role is acceptable to the bridge.
    Ok = 0,
    /// The requested version is unsupported.
    UnsupportedVersion = 1,
    /// The requested role is invalid or not correct for the given bridge address (e.g. a server
    /// connected to the client port).
    InvalidRole = 2,
    /// The client certificate is signed by a valid CA, but does not include a Common Name field.
    MissingCommonName = 3,
    /// The request did not begin with the correct magic number.
    MissingMagic = 4,
}

impl From<&Error> for BridgeStatus {
    fn from(value: &Error) -> Self {
        match value {
            Error::MissingCommonName => BridgeStatus::MissingCommonName,
            Error::InvalidRole => BridgeStatus::InvalidRole,
            Error::UnsupportedVersion => BridgeStatus::UnsupportedVersion,
            Error::MissingMagic => BridgeStatus::MissingMagic,
        }
    }
}

/// The bridge sends this acknowledgement to connections after receiving the protocol header.
/// The client and server can use this to determine if the inner connection can proceed, and
/// it also includes a session ID so logs across the services can be corrolated.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone)]
pub(crate) struct ProtocolAck {
    pub(crate) session_id: U128,
    status: BridgeStatus,
}

impl ProtocolAck {
    pub fn new(status: BridgeStatus) -> Self {
        Self {
            session_id: U128::new(Uuid::now_v7().as_u128()),
            status,
        }
    }

    #[instrument(level = "trace", skip_all, err)]
    pub(crate) async fn check<C: AsyncRead + Unpin>(conn: &mut C) -> Result<Uuid, ConnectionError> {
        let mut ack_buf = [0_u8; std::mem::size_of::<Self>()];
        conn.read_exact(&mut ack_buf).await?;
        let ack = Self::try_ref_from_bytes(&ack_buf)?;
        let session_id = Uuid::from_u128(ack.session_id.get());
        tracing::debug!(?session_id, status=?ack.status, "Bridge acknowledgement received");

        match ack.status {
            BridgeStatus::Ok => Ok(session_id),
            BridgeStatus::UnsupportedVersion => {
                Err(ConnectionError::Protocol(Error::UnsupportedVersion))
            }
            BridgeStatus::InvalidRole => Err(ConnectionError::Protocol(Error::InvalidRole)),
            BridgeStatus::MissingCommonName => todo!(),
            BridgeStatus::MissingMagic => todo!(),
        }
    }
}

impl ProtocolHeader {
    /// Create a new protocol header for the given role.
    pub(crate) fn new(role: Role) -> Self {
        Self {
            magic: MAGIC,
            version: PROTOCOL_VERSION,
            role,
        }
    }

    #[instrument(level = "trace", skip_all, err)]
    pub(crate) async fn check<C: AsyncRead + Unpin>(
        conn: &mut C,
        expected_role: Role,
    ) -> Result<(), ConnectionError> {
        let mut header_buf = [0_u8; std::mem::size_of::<Self>()];
        conn.read_exact(&mut header_buf).await?;
        let header = Self::try_ref_from_bytes(&header_buf)?;

        if header.magic != MAGIC {
            Err(ConnectionError::Protocol(Error::MissingMagic))
        } else if header.version != PROTOCOL_VERSION {
            Err(ConnectionError::Protocol(Error::UnsupportedVersion))
        } else if header.role != expected_role {
            Err(ConnectionError::Protocol(Error::InvalidRole))
        } else {
            tracing::debug!(header=?header, "Protocol header passed validation");
            Ok(())
        }
    }
}

impl From<Role> for ProtocolHeader {
    fn from(role: Role) -> Self {
        ProtocolHeader::new(role)
    }
}

/// Get the remote connection's commonName from its certificate.
pub(crate) fn peer_common_name<S>(stream: &SslStream<S>) -> Result<String, Error> {
    stream
        .ssl()
        .peer_certificate()
        .and_then(|cert| {
            cert.subject_name()
                .entries_by_nid(Nid::COMMONNAME)
                .next()
                .and_then(|entry| entry.data().as_utf8().ok())
        })
        .map(|common_name| common_name.to_string())
        .ok_or(Error::MissingCommonName)
}

/// Possible errors due to protocol violations.
#[derive(Debug, thiserror::Error)]
#[non_exhaustive]
pub enum Error {
    /// The client certificate does not include a Common Name, which is used to determine the
    /// username of the client.
    #[error("The peer's certificate does not include a Common Name")]
    MissingCommonName,
    /// The connection did not include the correct magic number in the header; this is likely
    /// due to something other than a Sigul client connecting.
    #[error("The connection did not begin with the correct magic number")]
    MissingMagic,
    /// The role used by the connection does not match with the expected role of the socket.
    /// This is likely a mis-configuration in the connecting service, but you should consider
    /// setting up a firewall rule to ensure the connecting client can't reach this port.
    #[error("The requested role is invalid for the service port")]
    InvalidRole,
    /// The connection requested a version of the protocol that is not supported by all parties.
    #[error("The requested protocol version is not supported.")]
    UnsupportedVersion,
}

/// Each client request or server response starts with a frame that describes the size of the request
/// to follow.
///
/// TODO: if something like JSON doesn't work for all commands, we could do something where a
/// request/response is a list of frames so they can have mixed content types. But I think JSON will
/// be fine for everything, so let's keep it simple for now.
#[derive(IntoBytes, Immutable, KnownLayout, TryFromBytes, Debug, Clone)]
pub(crate) struct Frame {
    /// The
    pub(crate) json_size: U64,
    pub(crate) binary_size: U64,
}

// TODO maybe don't be fancy. Request responses always need to be JSON, and optionally can have an arbitrary command-specific bag of bytes following it
// Drop the content type, size becomes request_size, add payload_size.

impl Frame {
    /// Create a new frame.
    pub fn new(json_size: u64, binary_size: u64) -> Self {
        Self {
            json_size: U64::new(json_size),
            binary_size: U64::new(binary_size),
        }
    }
}

/// Messages between the client and server are serialized via this enum.
///
/// Clients send requests, servers send responses. Currently, the only supported
/// content type is JSON.
///
/// The following example is the JSON-serialized "hello" request. The top-level object
/// has three keys, all of which are required. The `payload` key will always contain a
/// single key that is either `"request"` or `"response"` and has a dictionary value.
/// The contents of that dictionary are defined in the [`Request`] and [`Response`]
/// enumerations.
///
/// # Example
/// ```
/// # use serde_json::Result;
/// # use siguldry::v2::protocol::Message;
/// # fn main() -> Result<()> {
/// let data = r#"
///     {
///         "session_id": "00000000-0000-0000-0000-000000000000",
///         "request_id": 42,
///         "payload": {
///             "request": {
///                 "hello": {}
///             }
///         }
///     }
/// "#;
/// let hello_request: Message = serde_json::from_str(data)?;
///
/// # Ok(())
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub(crate) struct Message {
    /// The session ID this request is a part of.
    session_id: Uuid,
    /// The request ID; this should be a unique integer within the session,
    /// but has no other requirements. The response will include the same ID
    /// so it can be used to ensure the response matches the request.
    request_id: u64,
    /// The serialized [`Request`] or [`Response`].
    payload: Payload,
}

/// The payload of a message between the server and client.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub(crate) enum Payload {
    Request(Request),
    Response(Response),
}

/// The set of requests a client and server must support.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub(crate) enum Request {
    WhoAmI {},
    NewUser { username: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub(crate) enum Response {
    WhoAmI { user: String },
}

#[cfg(test)]
mod tests {
    use uuid::Uuid;

    use super::*;

    #[test]
    fn json_command_serialization() -> anyhow::Result<()> {
        let expected = "\
        {\"session_id\":\"00000000-0000-0000-0000-000000000000\",\
        \"request_id\":42,\
        \"payload\":{\
        \"request\":{\"new_user\":{\"username\":\"jcline\"}}}}";
        let value = Message {
            session_id: Uuid::nil(),
            request_id: 42,
            payload: Payload::Request(Request::NewUser {
                username: "jcline".to_string(),
            }),
        };
        let actual = serde_json::to_string(&value)?;

        assert_eq!(expected, actual);
        Ok(())
    }

    #[test]
    fn json_deserialize_message() -> anyhow::Result<()> {
        let data = r#"{
                "session_id": "00000000-0000-0000-0000-000000000000",
                "request_id": 42,
                "payload": {
                    "request": {
                        "who_am_i": {}
                    }
                }
            }"#;
        let hello_request: Message = serde_json::from_str(data)?;
        assert!(matches!(
            hello_request.payload,
            Payload::Request(Request::WhoAmI {})
        ));
        assert_eq!(hello_request.session_id, Uuid::nil());

        Ok(())
    }
}
